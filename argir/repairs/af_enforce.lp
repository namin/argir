% AF Enforcement: Minimal edits to make goal accepted
% Base AF from facts (provided externally)
% arg0(A). - original arguments
% att0(A,B). - original attacks
% goal(G). - goal to be accepted

% Arguments (can't delete, but can add defender)
arg(A) :- arg0(A).
arg(def) :- use_defender.

% Attacks with edit choices
att(A,B) :- att0(A,B), not del_att(A,B).
att(A,B) :- add_att(A,B).

% Edit candidate universe (generated by Python)
{ del_att(X,Y) } :- att0(X,Y), cand_del(X,Y).
{ add_att(X,Y) } :- arg0(X), arg0(Y), not att0(X,Y), cand_add(X,Y).

% Optional: add one fresh defender that can attack goal's attackers
{ use_defender }.
{ add_att(def, X) : arg0(X), attacks_goal(X) } :- use_defender.
attacks_goal(X) :- att0(X,G), goal(G).

% Grounded semantics encoding
defeated(X) :- arg(X), att(Y,X), in(Y).
in(X) :- arg(X), not defeated(X).

% Constraint: goal must be accepted
:- goal(G), not in(G).

% Minimize edit cost
#minimize { 1@1,X,Y : del_att(X,Y);
           1@1,X,Y : add_att(X,Y);
           2@2 : use_defender }.

% Output edits
#show del_att/2.
#show add_att/2.
#show use_defender/0.
#show in/1.